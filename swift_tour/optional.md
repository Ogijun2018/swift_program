# オプショナル

Swift の特徴の一つ。

オプショナル型とは…整数や文字列などのデータを持っているという通常の状態に加えて、「扱うデータがない」という状態をとりえる型。

使用用途

- 辞書からデータを取り出すとき
- クラスのインスタンスを扱うとき
- Objective-C の API を使うとき etc

扱うべき値が存在しないことを示すため、`nil`という特別な値を用いる。

未設定やエラーなどの状態を表すことがある場合、その値を`nil`で表現する。

整数の場合、変数や式の型は`Int`型だが、通常は`Int`型の値をもち、特殊な場合に`nil`を値として持つことがある場合は`Int?`という型で扱う。

例:

```
var a : Int = 0
var b : Int? = 10
b = nil // 代入可能
a = nil // エラー
```

オプショナル型の変数または定数を、初期値を設定しないで宣言した場合初期値の規定値は nil になる。

この仕組みの目的:

<b>nil を通常の値と謝って使ってしまうことを防止する</b>ため。

誤って NULL ポインタにアクセスしてしまい、実行時エラーが引き起こされることがよくあった。

オプショナル型を使うことによってこのような誤りを少なくできると期待されている。

オプショナル型は、データ型のイニシャライザの返り値にも使われる。

何らかの理由によって正しくデータを生成できない場合に nil を返すイニシャライザを<b>失敗のあるイニシャライザ</b>と呼ぶ。

Int 型のイニシャライザのうち、文字列を引数とするイニシャライザの例:

```
let olympic = "2020"
var year : Int? = Int(olympic) // 2020が返される
var city : Int? = Int("Tokyo") // nilが返される
```

オプショナル型は Int 型ではないので、そのまま Int 型の変数に値を代入したり、Int 型として式の中で演算に使うこともできない。

→ <b>開示(unwrap)</b>するために`!`(開示指定)を用いる。

`!`は手前におくと論理否定演算子とみなされるが、開示指定は後ろにおく。

例:

```
// 通常時
let year : Int? = Int("2020")
let next : Int = year! + 4    // 開示指定が必要
```

```
// yearにnilが入っている場合
let year : Int? = Int("令和20年") // yearの値はnil
let next : Int = year! + 4        // 実行時エラーになる
```

値が nil の場合はエラーになる。

先に比較を行ってしまえば実行時エラーが起きることはない。

```
var nagano : Int? = Int("1998")
if nagano != nil {              // true. 開示指定は使わない
  print("Nagano: \(nagano!)")   // ここでは開示指定が必要
}
if nagano == 2020 {             // false. 開示指定は使わない
  print(2020)
}
```

オプショナル型の値を開示せずに print の中に使ったり文字列の埋め込みに使ったりすると、コンパイル時にエラーが表示される。

値は開示されてから表示するべきであり、大体間違いのことが多い。

これを踏まえてコンパイル時に警告を無視して表示するには、String 型のイニシャライザ`init(describing:)`を使用する。

```
var n: Int? = nil, t: Int? = 1000
print(String(describing: n), "+", String(describing: t))
// "nil + Optional(1000)"を表示
```

## オプショナル束縛構文

### if-let 文

オプショナル型の式の値が nil でなかった場合、その値を if 文の then 節ですぐ使いたい場合、このように書く。

```
let year : Int? = Int("1986")
if let y = year {                        // この書き方に注意！
  print("ハレー彗星は\(y + 75)年に来る") // yはInt型。開示指定不要。
} else {
  print("error")
}
```

これを</b>オプショナル束縛</b>と呼ぶ。if-let 文とも呼ばれる。

元のオプショナル型の変数などと同じ名前を使うこともできる。実際によく使われている。

```
let halley : Int? = Int("1986")
if let halley = halley {
  print("ハレー彗星は\(halley)年にきた")
  halley += 75
  print("次は\(halley)年だと予想されている")
}
```

複数のオプショナル型の値で条件文を使いたい場合、ネストすることもできるが`,`で区切ることもできる。

```
if let sapporo = Int("1972"), let nagano = Int("1998") {
  print("\(nagano - sapporo) years.")
}
```

条件式は左から右に向かって順に評価されるので、こんな感じにもかける。

```
var nagano = 1998
if nagano < 2000, let tokyo = Int("2020"), tokyo > nagano {
  print("\(tokyo - nagano)") //22を表示
}
```

要するに、`&&`と同じような評価の仕方をする。`||`が存在しないのは、nil が含まれる場合に if の条件を成立させることはないから。

通常の条件式をカンマ区切りで書いても問題なく動作する。

### guard 文

想定外の状況が発生した場合にその処理から抜け出すための構文。

`guard 条件 else {/*breakやreturn*/}`

else 節は必ず書かなければならず、guard 文を含む現在実行中のコードブロックから抜け出す効果のある文を記述しなければならない。

この文で if と異なる点は、条件のオプショナル束縛に記述した定数や変数を guard 文の後続の文で利用可能である点。

例:

```
let stock = ["01", "2", "4", "05", "q", "X"]
for str in stock {
  guard let v = Int(str) else { // 条件が成立しない場合
    print(str + "??")
    break
  }
  print(v, terminator:" ") // guard文の条件で宣言した定数が利用できる
}
// 1 2 4 5 q?? と表示される
```

guard 文を適切に使うと、例外的な状況への対応とそこからの脱出をコンパクトに記述できる。

### nil 合体演算子

`opt ?? S`

` (opt != nil) ? opt! : S` と同じような動作をする。

「文字列 str を数値として評価した結果を変数 val に代入したいが、数値として評価できなければ値は 0 にする」を以下の文で表現できる。

`val = Int(str) ?? 0`

if-let 文と同じように、右にどんどん連結することもできる。途中で nil ではない値が出てきたら、評価はそこまでになる。

`val = x ?? y ?? z ?? 0`

## オプショナル型と関数

関数やメソッドで、オプショナル型を引数、あるいは返り値とするものを定義できる。

```
func nickname(_ name: String?, age: Int) -> String {
  let s = name ?? "名無し"
  return "浪速の" + s + "(\(age)歳)"
}
```

これに対し、

```
nickname("シンデレラ", age: 35) //"浪速のシンデレラ(35歳)"
nickname(nil, age: 20) //"浪速の名無し(20歳)"
```

オプショナル型の引数には、オプショナル型の値をそのまま指定することもできる。

```
var name : String? = "海賊王"
print(nickname(name, age: 25)) // "浪速の海賊王(25歳)"
```

### 関数の inout 引数に指定する

inout 引数(関数呼び出しの際の元変数の値を変更することができる)にオプショナル型を使うことができる。

```
func makeNil(_ p: inout String?) {
  if let s = p, s && "" { p = nil }
}
```

実行すると次のような結果になる。

```
var w : String? = ""
makeNil(&w) //ここの詳しい解説は関数でしている
print(w ?? "nil") //"nilが表示される
```

### readLine 関数

Swift の入力用関数。

返り値は String?型で、EOF の際に nil を返す。

```
// 関数readLine()を使って行番号をつける
var num = 0
while let time = readLine() {  // while-let文
    num += 1
    print("\(num)  " + line)
}
```

## 有値オプショナル型

プログラムの前後関係から、確実に nil 以外の値を持っていると判断できる場合もある。

そこで、オプショナル型のもう一つの形態として、開示指定をしなくても普通の変数のように分や式の中で利用できる型が用意されている。→ <b>有値オプショナル型</b>

有値オプショナル型は、型宣言の際に`?`ではなく`!`を使う。

開示指定をせずに式の中に記述すると、コンパイラが判断して、自動的に開示した値を使う。

それ以外は通常のオプショナル型と同様。

例:

```
let year : Int! = Int("1986")
print("ハレー彗星は\(year + 75)年にくる")
```

値が nil ではないと判断するのはプログラマなので、変数が nil を値とするような用途で、有値オプショナル型を使うべきではない。

有値オプショナル型の典型的な利用例は、GUI の部品を管理するクラスのプロパティの初期化部分など。

### オプショナル型を要素とする配列

`var mark : [Int?] = [ 10, 5, nil, 7, 3, nil, 0]`

試験の点数を配列に格納する場合、欠席を nil で表せば出席して 0 点のときと区別することができる。

有値オプショナル型の扱いは、<b>初期値だけは nil かもしれない変数を便利に扱う</b>という目的を考えると納得できる。

## 失敗のあるイニシャライザ

### イニシャライザで正しく処理ができない場合

初期化されたインスタンスを返す通常のイニシャライザの他に、インスタンスまたは nil を返す、オプショナル型のイニシャライザを定義することができる。

→ 失敗のあるイニシャライザと呼ぶ。

初期化に失敗したときに、異常を知らせるために nil を返す。

例: 指定した時と分が通常の班を超えていた場合に、初期化に失敗するイニシャライザ

```
import Foundation    // 現在時刻をCalendarとDateを使って得る

struct SimpleTime {
  let hour, min : Int
  init?(_ h:Int, _ m:Int) { // 時と分を指定する「失敗のある」初期化
    if h < 0 || h > 23 || m < 0 || m > 59 {
    return nil // 初期化に失敗
    }
  hour = h
  min = m // 普通に初期化できたときは return は使わない
  }

  init() { // 現在時刻を返す「失敗のない」初期化
    var calendar = Calendar.current // Foundation の構造体
    calendar.timeZone = TimeZone(abbreviation: "JST")!
    // タイムゾーンを得る失敗のあるイニシャライザ
    let d = Date() // Foundation の構造体
    hour = calendar.component(.hour, from: d) //.hour は列挙型
    min = calendar.component(.minute, from: d) //.minute は列挙型
  }
}

```

実際に呼び出してみると、

```
if let u = SimpleTime(13, 72) { // エラー発生
  print("\(u.hour): \(u.min)") // 表示しない
}
let a : SimpleTime = SimpleTime(14,30)! // 開示を指定
let c : SimpleTime = SimpleTime()
print("\(a.hour):\(a.min)") // 14:30 を表示
print("\(a.hour):\(a.min)") // 現在時刻を表示

```

## 会員登録を例に考える

会員登録には必須項目とオプション項目の 2 種類がある。

「オプショナル」とは、オプション項目と同じ意味を持つ。

年齢をオプション項目とする場合、整数型の変数を用意すれば良さそう →「ない」場合を表すには？→「-1」だと他の項目では使えない →nil を使う
