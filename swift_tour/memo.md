## AppDelegate.swift

ユーザーがアプリを起動した際に最初に呼ばれるファイル。

アプリを管理するためのコードが含まれている。

アプリ起動時のタイミングなどに動作を変更したい場合はこのファイルにコードを書く。

構造体にはプロパティとメソッドがある。

プロパティには「ストアドプロパティ（値を保持するためのプロパティ）」と「コンピューテッドプロパティ（値を計算するためのプロパティ）」がある。

関数の宣言時にラベルに「\_」を指定すると、関数の呼び出し時にラベルはかけない。

「ラベルをつけることによって関数名が不自然な英文になってしまうのを防ぐこと」などが理由。

Swift では通常、メソッドはプロパティよりも下に書く。

クロージャの書式

```
{(引数名: 型) -> 戻り値の型 in
    文
}
```

## トレイリングクロージャ

```
Button(action: {self.count += 1}){
  Text("カウント")
}
```

Button 構造体のイニシャライザの末尾には、ドキュメントにはない`{}`がある

**これをトレイリングクロージャといい、最後の引数がクロージャの場合はそのクロージャを`()`の外に出し、その引数名を省略することができる**

という仕様がある。(trailing とは「後の」と言う意味。)

## VStack(Vertical Stack)

VStack は UI 部品の一つ。VStack 構造体のイニシャライザには`()`がない。

理由: 引数がクロージャ一つだけの場合は、そのクロージャを`()`の外に出した後、引数名と`()`を省略できるから（トレイリングクロージャ）

VStack, HStack, ZStack がある。それぞれ、縦に並べる・横に並べる・重ねる構造。

## プロパティラッパー

`@State var number = 0`の部分。

`@State`…プロパティの先頭におくと、そのプロパティの値が変更された時に、**自動的に iPhone の画面が更新される(State の役割)**

`@Binding`…プロパティの先頭におくと、そのプロパティの値が変更された時に、**親の UI 部品のプロパティも変更される**

## 画像の追加

イメージセットに表示される 3 つの枠

1x…非レティナディスプレイ用の画像

2x…レティナディスプレイ用の画像

3x…レティナ HD ディスプレイ用、スーパーレティナ HD ディスプレイ用の画像

## 列挙体

独自の型を定義するための機能。

```
enum 列挙体名 {
  case 値名
  case 値名
  ...
}
```

`enum`は enumeration の略。列挙体名は慣例的に先頭大文字の英字で指定する。

一つの列挙体名で同じ値名を複数宣言することはできない。

例: 曜日を表す列挙体 Week を宣言する場合は、次のようになる。

```
enum Week {
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  case sunday
}
```

列挙体の値の取得には`var 変数名 = 列挙体名.値名`で取得。

列挙体がなぜあるのか？

→ 引数に同じ型が使える場合（Int だったとしたら）、誤って想定とは違う値を入れることができてしまい、実行前にエラーを特定することができないから。

### インスタンスプロパティとタイププロパティの違い

構造体とインスタンスの関係は、たい焼きの金型とたい焼きの関係と似ている。

一方、たい焼きの中身はそれぞれに異なるため、たい焼きを作ってみないと確認できない。

このことから、例えば「たい焼きの中身を格納するプロパティ」が存在した時に、このプロパティの値はたい焼きを生成したあとでないと設定できない。

これが一般的なプロパティであるインスタンスプロパティ。

一方、たい焼きに背ビレがあるかどうかは金型を見ればわかる。わざわざたい焼きを作って確認する必要はない。

この場合における「たい焼きに背ビレがあるかどうかの情報を格納するプロパティ」がタイププロパティ。

構造体のプロパティをタイププロパティにするには、プロパティの宣言文の文頭に`static`をつける。

```
struct 構造体名 {
  static var タイププロパティ名 = 初期値
}
```

タイププロパティはインスタンスを作成する必要はないので、構造体の宣言後に`()`はつかない。

### インスタンスメソッドとタイプメソッド

メソッドも同様にインスタンスメソッドとタイプメソッドに分類できる。

- インスタンスメソッド…インスタンスから呼び出すメソッド
- タイプメソッド…構造体から直接呼び出すメソッド

```
struct Taiyaki {
  static func hasFin() -> bool{
    return true
  }
}
Taiyaki.hasFin()
```

構造体や列挙体は入れ子にすることができる。

```
struct 構造体名 {
  enum 列挙体名 {
    struct 構造体名 {

    }
  }
}
```

ドットであらゆる階層へアクセスできる。

## クラスとは

UI 部品を作るためのテンプレートのこと。

構造体と異なるところは

- 宣言時に書くキーワードが`struct`ではなく、`class`になるという点。

例: Taiyaki クラスの宣言

```
class Taiyaki {
  var nakami = "あんこ"
  func sayNakami() {
    print(nakami)
  }
}
```

`var taiyaki = Taiyaki()`

- **構造体は「値型」、クラスは「参照型」**

オリジナルの型を作る場合はなるべく構造体を利用する方が良い。

→ じゃあなぜ MapKit はクラスなのか？

→ MapKit は昔型ある古いフレームワークだから

### 古いフレームワークの使い方

body の戻り値は`some View`で、この型は SwiftUI フレームワークに含まれている UI 部品しか受け付けない。

しかし、MKMapView は MapKit フレームワークの UI 部品。

iOS には古いフレームワークが多数含まれているので、必ず**橋渡しするコード**が必要になる。

```
struct 構造体名: UIViewRepresentable {
  func makeUIView(context: Context) -> クラス名 {
    return クラス名()
  }
  func updateUIView(_ uiView: クラス名, context: Context) {
  }
}
```

## プロトコル

```
protocol プロトコル名 {
}
```

プロトコルは構造体といたような仕組みなので、プロパティ（ストアドプロパティ・コンピューテッドプロパティ）・メソッドが中に持つことができる。

ポイント 1: **プロトコルにはメソッドの中身を書かない**

```
protocol KyotoProtocol {
  func stopGlobalWarming()
}
```

プロトコルで重要なのは「どの国がこのプロトコルに参加するか」。→ 批准(conform)と呼ぶ

例: Japan 構造体が KyotoProtocol を批准する

```
struct Japan: KyotoProtocol {
  // そのプロトコルに定義されているメソッドを実装する必要がある
  func stopGlobalWarming() {
    print("クリーンエネルギーを推進します")
    print("森林を増やします")
  }
}
```

ポイント 2: プロトコルのプロパティ

```
protocol プロトコル名 {
  var プロパティ名: 型 { get set }
}
```

例: KyotoProtocol の宣言

```
protocol KyotoProtocol {
  // ストアドプロパティ
  var co2: Double { get set }
  // コンピューテッドプロパティ getのみの部分に注意
  var carbonTax: Double { get }
}
```

例: KyotoProtocol を批准した Japan 構造体がプロパティを宣言する

```
struct Japan: KyotoProtocol {
  // ストアドプロパティ
  var co2: Double = 42
  // コンピューテッドプロパティ
  var carbonTax: Double {
    co2 * 0.01
  }
}
var japan = Japan()
print(japan.co2)        // 42.0と表示される
print(japan.carbonTax)  // 0.42と表示される
```

ポイント 2: **プロトコルを型として使う**

変数名を宣言する際に、変数名の後ろに`:`をつけてプロトコル名を指定すると、その変数はそのプロトコルを批准している構造体専用の箱になる。

例: 変数の型に KyotoProtocol を指定する

```
var country: KyotoProtocol = Japan()
```

変数 country には、KyotoProtocol を批准している構造体のインスタンスしか格納できなくなる（エラーになる）。

→ 通常の型の場合と同様にアプリ実行前にエラーを見つけることができる。

## ContentView 構造体の詳細解説

```
struct ContentView: View {
    var body: some View {
        Text("Hello")
    }
}
```

ContentView 構造体は View プロトコルに批准している

View プロトコルはテキスト・ボタン・スライダーなどの SwiftUI フレームワークにある UI 部品が必ず批准しなければならないプロトコル。

→ View プロトコルに批准している構造体だけが、iPhone が画面に表示することができる。

MKMapView クラスも View プロトコルに批准していないので、橋渡しのコードが必要だった。

## タプル

```
Button(action: {
    self.isJapanese = true
    self.japanese = self.cards.randomElement()!.key
}) {
    Text("次へ")
}
```

`self.cards.randomElement()!.key`…辞書の中からランダムにキーを取得するコード

`randomElement()`…辞書の中からランダムに 1 つの要素を返すメソッド

```
func randomElement() -> (key: String, value: String)?
```

このメソッドの返り値は`(key: String, value: String)?`である。

この戻り値の書き方を「**タプル**」という。

タプルとは、**複数の値を一つの変数にまとめる機能**のこと。

`var 変数名 = (要素名: 値, 要素名: 値, ...)`

このタプルから値を取り出すときはドットシンタックスを使って、`変数名.要素名`とする。

タプルと配列・辞書との最大の違いは、**タプルには異なる型の要素を格納できる**こと。

もう一つは、**タプルでは要素の追加・削除が行えない**という大きなデメリットがある。

また、返り値には`?`がついているため、オプショナル型であることがわかる。

例えば、辞書 cards が空の場合は nil が返される。
