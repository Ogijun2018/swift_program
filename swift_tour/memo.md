## AppDelegate.swift

ユーザーがアプリを起動した際に最初に呼ばれるファイル。

アプリを管理するためのコードが含まれている。

アプリ起動時のタイミングなどに動作を変更したい場合はこのファイルにコードを書く。

構造体にはプロパティとメソッドがある。

プロパティには「ストアドプロパティ（値を保持するためのプロパティ）」と「コンピューテッドプロパティ（値を計算するためのプロパティ）」がある。

関数の宣言時にラベルに「\_」を指定すると、関数の呼び出し時にラベルはかけない。

「ラベルをつけることによって関数名が不自然な英文になってしまうのを防ぐこと」などが理由。

Swift では通常、メソッドはプロパティよりも下に書く。

クロージャの書式

```
{(引数名: 型) -> 戻り値の型 in
    文
}
```

## トレイリングクロージャ

```
Button(action: {self.count += 1}){
  Text("カウント")
}
```

Button 構造体のイニシャライザの末尾には、ドキュメントにはない`{}`がある

**これをトレイリングクロージャといい、最後の引数がクロージャの場合はそのクロージャを`()`の外に出し、その引数名を省略することができる**

という仕様がある。(trailing とは「後の」と言う意味。)

## VStack(Vertical Stack)

VStack は UI 部品の一つ。VStack 構造体のイニシャライザには`()`がない。

理由: 引数がクロージャ一つだけの場合は、そのクロージャを`()`の外に出した後、引数名と`()`を省略できるから（トレイリングクロージャ）

VStack, HStack, ZStack がある。それぞれ、縦に並べる・横に並べる・重ねる構造。

## プロパティラッパー

`@State var number = 0`の部分。

`@State`…プロパティの先頭におくと、そのプロパティの値が変更された時に、**自動的に iPhone の画面が更新される(State の役割)**

`@Binding`…プロパティの先頭におくと、そのプロパティの値が変更された時に、**親の UI 部品のプロパティも変更される**

## 画像の追加

イメージセットに表示される 3 つの枠

1x…非レティナディスプレイ用の画像

2x…レティナディスプレイ用の画像

3x…レティナ HD ディスプレイ用、スーパーレティナ HD ディスプレイ用の画像

## 列挙体

独自の型を定義するための機能。

```
enum 列挙体名 {
  case 値名
  case 値名
  ...
}
```

`enum`は enumeration の略。列挙体名は慣例的に先頭大文字の英字で指定する。

一つの列挙体名で同じ値名を複数宣言することはできない。

例: 曜日を表す列挙体 Week を宣言する場合は、次のようになる。

```
enum Week {
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  case sunday
}
```

列挙体の値の取得には`var 変数名 = 列挙体名.値名`で取得。

列挙体がなぜあるのか？

→ 引数に同じ型が使える場合（Int だったとしたら）、誤って想定とは違う値を入れることができてしまい、実行前にエラーを特定することができないから。

### インスタンスプロパティとタイププロパティの違い

構造体とインスタンスの関係は、たい焼きの金型とたい焼きの関係と似ている。

一方、たい焼きの中身はそれぞれに異なるため、たい焼きを作ってみないと確認できない。

このことから、例えば「たい焼きの中身を格納するプロパティ」が存在した時に、このプロパティの値はたい焼きを生成したあとでないと設定できない。

これが一般的なプロパティであるインスタンスプロパティ。

一方、たい焼きに背ビレがあるかどうかは金型を見ればわかる。わざわざたい焼きを作って確認する必要はない。

この場合における「たい焼きに背ビレがあるかどうかの情報を格納するプロパティ」がタイププロパティ。

構造体のプロパティをタイププロパティにするには、プロパティの宣言文の文頭に`static`をつける。

```
struct 構造体名 {
  static var タイププロパティ名 = 初期値
}
```

タイププロパティはインスタンスを作成する必要はないので、構造体の宣言後に`()`はつかない。

### インスタンスメソッドとタイプメソッド

メソッドも同様にインスタンスメソッドとタイプメソッドに分類できる。

- インスタンスメソッド…インスタンスから呼び出すメソッド
- タイプメソッド…構造体から直接呼び出すメソッド

```
struct Taiyaki {
  static func hasFin() -> bool{
    return true
  }
}
Taiyaki.hasFin()
```

構造体や列挙体は入れ子にすることができる。

```
struct 構造体名 {
  enum 列挙体名 {
    struct 構造体名 {

    }
  }
}
```

ドットであらゆる階層へアクセスできる。
